---
title: "Group project - Athen Airbnbs"
author: "Group 19: Daniel Zeiner, Balint XXX, Tao XXX, Mayssa XXX, Eudald XXX"
date: "`r Sys.Date()`"
output:
  html_document:
    theme: flatly
    highlight: zenburn
    number_sections: yes
    toc: yes
    toc_float: yes
    code_folding: show
---

```{r, setup, echo=FALSE}
knitr::opts_chunk$set(
  message = FALSE, 
  warning = FALSE, 
  tidy=FALSE,     # display code as typed
  size="small")   # slightly smaller font for code
options(digits = 3)

# default figure size
knitr::opts_chunk$set(
  fig.width=6.75, 
  fig.height=6.75,
  fig.align = "center"
)
```





```{r libraries, include=FALSE}
library(tidyverse)
library(ggplot2)
library(igraph)
library(ggmap)
library(geosphere)
library(sf)
library(rnaturalearth)
library(rnaturalearthdata)
library(mosaic)
library(ggthemes)
library(GGally)
library(skimr)
library(reticulate)


theme_set(theme_minimal())
theme_update(axis.line = element_line(colour = "#C8102E"))
theme_update(axis.text.x = element_text(colour= "#001E62",
                                 size = 10,
                                 family = "Arial"))
```

# Airbnb Project - Athens

## Introduction


## Summary of key findings




# Initial data analysis

```{r data, echo=FALSE}
# Data
athens_data <- read_csv("data/listings.csv")

glimpse(athens_data)
```

## Cleaning the data 


```{r}
skim(athens_data)
```

Based on our initial data analysis we identified 4 major types of variables in the underlying data set: 

1) Character values: 47
2) Date values: 5
3) Logical values: 15
4) Numeric values: 39

We also have seen that we have 11,314 observations (apartments) & a total of 106 data points per apartment. 


### Reducing the dataset 

We identified many variables that have a characteristic which make it either not interesting to analyze (only one/ very few distinct values, text strings) or that we think we will not use in the analysis later on. 

So we excluded these columns/ data points in order to make the data easier & faster to handle.


```{r}
athens_data_red <- athens_data %>% 
    #Select the relevant variables
  select(
         id,
         neighbourhood,
         zipcode,
         latitude,
         longitude,
         property_type,
         room_type,
         accommodates,
         bathrooms,
         bedrooms,
         beds,
         price,
         weekly_price,
         monthly_price,
         security_deposit,
         cleaning_fee,
         guests_included,
         extra_people,
         minimum_nights,
         maximum_nights,
         availability_365,
         number_of_reviews_ltm,
         review_scores_rating,
         review_scores_checkin,
         review_scores_cleanliness,
         review_scores_accuracy,
         review_scores_communication,
         review_scores_location,
         review_scores_value,
         cancellation_policy,
         reviews_per_month,
         host = host_id, 
         host_response_time,
         host_response_rate,
         host_acceptance_rate,
         host_is_superhost,
         host_listings_count,
         host_total_listings_count,
         host_identity_verified,number_of_reviews,
         host_instant_booking =  instant_bookable
  )

```


We now only have 41 columns left, which make the data set easier to handle. 

### Adjust data values

In a next step we will adjust the type of some variables so that we can actually can work with the data more easily. 

* We transform the price, weekly price, monthly price, security deposit, cleaning fee, extra people, host response rate and host acceptance rate from character variables to numeric ones
* We create factor variables for Property type, room types, cancellation policy and host response time 


```{r}
# Transform character values to numeric values
athens_data_clean <- athens_data_red %>% 
   mutate(
     price = as.numeric(str_remove_all(price, "[$ ,]")),
     weekly_price = as.numeric(str_remove_all(weekly_price, "[$ , ]")),
     monthly_price = as.numeric(str_remove_all(monthly_price, "[$ ,]")),
     cleaning_fee = as.numeric(str_remove_all(cleaning_fee, "[$ ,]")),
     security_deposit = as.numeric(str_remove_all(security_deposit, "[$ ,]")),
     extra_people = as.numeric(str_remove_all(extra_people, "[$ ,]")),
     host_response_rate = as.numeric(str_remove_all(cleaning_fee, "[% ,]")),
     host_acceptance_rate = as.numeric(str_remove_all(cleaning_fee, "[% ,]"))
     )
```


```{r}
# Create factor variables for room types 
room_types <- unique(athens_data_clean$room_type)
athens_data_clean$room_type <- factor(athens_data_clean$room_type, labels = room_types)

# Create factor variables for cancellation policies 
cancellation_policies <- unique(athens_data_clean$cancellation_policy)
athens_data_clean$cancellation_policy <- factor(athens_data_clean$cancellation_policy, labels = cancellation_policies)

# Create factor variables for host response time 
athens_data_clean <- athens_data_clean %>% 
  mutate(host_response_time = fct_relevel(host_response_time,
                                            "within an hour", 
                                            "within a few hours",
                                            "within a day",
                                            "a few days or more",
                                            ))
```


The issue with the property types is that there are to much in order to generate reasonable factors. We need to analyze how much the share of each category. Best case would be that the majority of the property type share is done with a small number. If that is the case we can just summarize the rest in a new category calles "other".


```{r}
# Identify the amount of each property type
most_com_properties <- athens_data_clean %>%
    count(property_type) %>%
    mutate(percentage = n/sum(n)*100)%>%
    arrange(desc(n))

most_com_properties
```

As the 5 most common property types account for ~95% of the total share we can just focus on them and summarize the rest in "Others"


```{r}

# First we need to summarize the other values in the Category "Others"
athens_data_clean <- athens_data_clean %>% 
  mutate(
    property_type = case_when(
      property_type %in% c("Apartment","House", "Condominium","Serviced Apartment", "Loft") 
      ~ property_type, 
      TRUE ~ "Other"))
    

# In a next step we can make a factor out of the 6 pre-defined categories    
athens_data_clean <- athens_data_clean %>% 
  mutate(
     property_type = fct_relevel(property_type,
                                        "Apartment",
                                        "House",
                                        "Condominium",
                                        "Serviced Apartment",
                                        "Loft",
                                        "Other"))

```


We now have transformed the data types of the most variables in order to make the data set even cleaner. We have deleted unnecessary values, adjusted wrong variable types and now we will further inspect the quality of our data. 

### Readjust NA values 

In a this step we will further manipulate the data set. In specific we will correct the NA values in cases in which we can estimate the value. 

* If no weekly price -> no discount -> we will insert the daily price multiplied by 7
* If no monthly price -> no discount -> we will insert the daily price multiplied by 30
* If no security deposit/ cleaning fee -> no fee -> we will insert 0


```{r}

# We will replace the NAs in the weekly prices and assume there is no discount if NA
 athens_data_clean$weekly_price[is.na(athens_data_clean$weekly_price)] <- 
  athens_data_clean$price *7


# We will replace the NAs in the monthly prices and assume there is no discount if NA
 athens_data_clean$monthly_price[is.na(athens_data_clean$monthly_price)] <- 
  athens_data_clean$price * 30


# We will replace the NAs in the security deposit & cleaning fee and assume 0 if NA
 athens_data_clean$cleaning_fee[is.na(athens_data_clean$cleaning_fee)] <- 0
 athens_data_clean$security_deposit[is.na(athens_data_clean$security_deposit)] <- 0


```


We now have cleaned the data to a nearly perfect amount. The only thing we haven't yet included are outliers which will be captured in the next paragraph. 

### Readjust outliers

We will screen the most important variable *price*, which we need in our analysis later on, for potential outliers. We will exclude the extreme values, which make no sense economically (way too high prices). Reasons which could explain these extremly high prices are *unwillingness to list at the moment*, *fake listings* or *extremly luxurious apartments*. 


```{r}

# Quick plot to see outliers
athens_data_clean %>% 
  ggplot(aes(x = price)) +
  geom_histogram() +
  labs(title= "Distribution of prices in our original data")

# Looks very scewed, probably a log-normal distribution, use log -> normal
athens_data_clean %>% 
  ggplot(aes(x = log(price))) +
  geom_histogram()

# There seem to be a few outliers. We will remove them using the IQR method, becauses we belive that keeping those values would skew our analysis
IQR.outliers <- function(x) {
  Q3 <- quantile(x,0.95)
  Q1 <- quantile(x,0.05)
  IQR <- (Q3-Q1)
  left <- (Q1-(1.5*IQR))
  right <- (Q3+(1.5*IQR))
  print(c(left, right))
  c(x[x <left],x[x>right])
}

# Print outliers
IQR.outliers(athens_data_clean$price)

athens_data_clean %>% 
  filter(!(price %in% IQR.outliers(athens_data_clean$price))) %>% 
  ggplot(aes(x = log(price))) +
  geom_histogram()


#Defining our final data set, which has no more outliers
athens_data_final <- athens_data_clean %>% 
  filter(!(price %in% IQR.outliers(athens_data_clean$price)))

```


## First analysis of data

As we now have finally derived with a data set, which has only the *relevant values*, *right variable types*, *adjusted NA values* and is *corrected for outliers*, we can finally start with the analysis of the data. 

### Analysis on location 

> How important is the location for the price? Are central locations more expensive?

```{r Syntagma distance}
# First we start with a simple plot, showing our Airbnbs
qmplot(longitude, latitude, data = athens_data_final, color = price)

# Syntagma coordinates
syntagma <- c(37.975344, 23.73472)
names(syntagma) <- c("longitude", "latitude")

# Athene map
athens_map = get_map(location=c(23.68,
                                37.945,
                                23.8,
                                38.035), maptype="terrain-background")

athens_map <- ggmap(athens_map)

# We dont want to see the axis when we are ploting maps
map_theme <-  theme(axis.title.x=element_blank(),
                    axis.text.x=element_blank(),
                    axis.ticks.x=element_blank(),
                    axis.title.y=element_blank(),
                    axis.text.y=element_blank(),
                    axis.ticks.y=element_blank())

# Plot the map and Syntagma, is there a connection between prices and the centre?
athens_map +
  geom_point(data=athens_data_final, aes(x = longitude, y = latitude, color = price)) +
  geom_point(aes(x = syntagma['latitude'], syntagma['longitude']), 
             color = 'red', size = 5) +
  theme_minimal() +
  map_theme +
  labs(title="Airbnbs around the centre seem to be more expensive", 
       subtitle = "Centre - Syntagma Square")
```

> According to the graph there seems to be a connection between the price and the distance to the center. We will now try to calculate the distance to the center and try to see if the colors of the two graphs fit.  

```{r Syntagma distance}
# Now that we assume that there is a connection, we calculate the distance for each airbnb
head(athens_data_final)

# Calculate the distance
athens_data_final<- athens_data_final %>% 
  rowwise() %>% 
  mutate(
    cent_dist = distm(c(latitude, longitude), c(37.975344, 23.73472), 
                      fun = distHaversine)[1,1]
  )

# Test if our numbers are correct visually
athens_map +
  geom_point(data=athens_data_final, aes(x = longitude, y = latitude, color = cent_dist)) +
  geom_point(aes(x = syntagma['latitude'], syntagma['longitude']), color = 'red', size = 5) +
  theme_minimal() +
  map_theme +
  labs(title = "Locations seem to impact the prices of the airbnbs - same pattern as above" , subtitle = "Distance from center in meters")

```

> If we compare this graph to the graph above, we can indeed see that the same regions tend to have the same colors. Therefore we conclude that the location will indeed have an impact on the price of the airbnbs and that Airbnbs located in nearer in the center tend to have on average a higher price. 

> Next we are going to explore if based on location there are differences in room types. We expect to have center locations to have on average smaller offerings (e.g. shared rooms)


```{r Room type}
# How many room types are there?
length(unique(athens_data_final$room_type))

avg_dist <- athens_data_final %>% 
  group_by(neighbourhood) %>% 
  summarise(
    avg_dist = mean(cent_dist)
  ) %>% 
  arrange(-avg_dist)

athens_data_final %>% 
  filter(!is.na(neighbourhood)) %>% 
  select(neighbourhood,
         room_type) %>% 
  group_by(neighbourhood,
           room_type) %>% 
  summarise(n = n()) %>% 
  mutate(perc = n/sum(n)) %>% 
  ggplot(aes(fill=room_type, x=perc, y=factor(neighbourhood,levels = avg_dist$neighbourhood))) + 
    geom_bar(position="fill", stat="identity") +
  labs(title="Average distance from the centre does not seem to impact room types",
       subtitle = "Average distance in decreasing order") +
  ylab("") +
  xlab("") +
  guides(fill=guide_legend(title="Room types"))
```

> We identified that there is no significance patterns visible. Our hypothesis that more central locations have a higher amount of shared rooms, private rooms than locations further away must therefore be invalid. 



### Analysis of rating

```{r}
#First we want to see how the ratings are distributed in general
athens_data_final %>% 
  ggplot(aes(x=review_scores_rating)) +
  geom_histogram() +
  # Due to the high skew in distribution, a log y scale makes it easier to read
  scale_y_log10() +
  xlab("Review scores rating") +
  ylab("Quantity") +
  labs(title = "Most hosts seem to convince the tentants of their apartment", subtitle = "High negative skew in distribution") +
  theme_minimal()
  
```



```{r}
# We want to see if the response time has an influence on the general rating of the apartment
# create a bar chart to see the review scores based on response time
athens_data_final %>% 
  filter(host_response_time != "N/A" & !is.na(host_response_time)) %>% 
  group_by(host_response_time) %>% 
  ggplot(aes(x=host_response_time, y=review_scores_rating)) +
  geom_boxplot() +
  ylim(85,100) +
  xlab("Host response time") +
  ylab("Review Scores rating") +
  labs(title = "Fast response time not valued enough to have impact on rating", subtitle = "The longer the response time the higher the median rating") +
  theme_minimal()


```


> We identified that the response time has not a huge impact on the general rating of the Airbnb. We will now try to identify more significant factors. Let's try to test if the price per bed influences the rating. 

```{r}
# We want to see if the price is a significant factor for the rating
# In order to reduce the bias in the data we will use the price per bed 

athens_data_final %>% 
  summarize(
    price_per_bed = price/beds,
    review_scores_rating
  ) %>% ggplot(aes(x=price_per_bed, y=review_scores_rating)) +
  geom_point() +
  scale_x_log10() +
  ylim(60,100) +
  xlab("Price per bed") +
  ylab("Review Score Rating") +
  labs(title = "No correlation between price per bed and review score", 
       subtitle = "Distribution of review scores and price per bed") +
  theme_minimal()




```

> Once again we cannot identify a clear trend in the data. They seems to be no correlation between the price per bed and the average rating. We will give the analysis one last try and explore if the rating is influenced by the fact if the host is a superhost (which has many responsibilites compared to a normal host) or not. 

```{r}

# Analysis if superhost status has a positive impact on the rating
athens_data_final %>% 
  filter(!is.na(host_is_superhost)) %>% 
  ggplot(aes(x=host_is_superhost, y=review_scores_rating)) +
  geom_boxplot() +
  ylim(60,100) +
  xlab("Host is superhost?") +
  ylab("Review Score Rating") +
  labs(title = "Superhosts seem to make people happier during their stay", 
       subtitle = "Rating distribution based on Superhost criterion") +
  theme_minimal()



```

> Finally we found a relationship. In our eyes this makes completely sense - in order to receive a superhost rating you need to fulfill a lot of requirements (e.g. you are not allowed to cancel as soon as you have accepted hosts & you need to have specific response times etc.). Therefore, the superhost variable includes a lot of positive attributes, which kind of explains that people feel that stays in their apartments worked out particulariy well. Many of them also do this professionally and therefore value reputation a lot. 

> We were quite surprised that neither the price per bed nor the response time of the host (which we have seen as an indicator of the commitment from host side) played a major role in the overall rating. We came up with possible explainations. We think that the price has no impact as people book apartments based on their individual price preferences and then rate the stay according to their experiences. Therefore the price criterion is outweighted by other factors. Regarding the host response time, we concluded that this variable probably doesn't reflect the commitment of the host in an ideal way. There are many more factors, which are not included - therefore the general impact of the response time is too low to see any impact. 

### Analysis of room type

We haven't yet analyzed the room type. However, we have the hypothesis that the room type will impact the price which can be achieved with an apartment. 

Is there a difference in price among room types?

```{r}
# create a plot to show the density and distribution for the price grouped by each room type
athens_data_final %>% 
  ggplot(aes(x=price, y=room_type, fill=room_type)) +
  geom_violin( ) +
  # make differences more visible in relevant interval
  xlim(0,250) +
  # In order to make differences more visible
  scale_x_log10() +
  xlab("Price") +
  ylab("Density") +
  stat_summary(fun.y=median, geom="point", size=3, color="black") +
  labs(title = "Private rooms with highest median prices, closely followed by whole apartments",
       subtitle = "Distribution of price per room type") +
  theme_minimal() +
  theme(strip.text.x = element_text(size = 10), legend.position = "none")

```

> First we were quite confused that private rooms are on average more expensive than the apartments. However after having a look of the quanitity of the room types we identified that apartments are way more common than shared rooms. As the overall data quantity is so little compared to apartments, it's likely that outliers adjust the price upwards. It makes sense that shared rooms are really cheap, in the rante between 10 and 30 Euro per night. 

We will now conduct the same analysis but adjust (like above) the price by the amount of persons the apartment can carry. We expect the results to be more equally distributed. 


```{r}
# create a  plot to show the density and distribution for the price per person grouped by each room type
athens_data_final %>% 
  ggplot(aes(x=price/accommodates, y=room_type, fill=room_type)) +
  geom_violin() +
  # make differences more visible in relevant interval
  xlim(0,250) +
  # In order to make differences more visible
  scale_x_log10() +
  xlab("Price") +
  ylab("Density") +
  stat_summary(fun.y=median, geom="point", size=3, color="black") +
  labs(title = "Differences in prices per person smaller between apartment types",
       subtitle = "Distribution of price per person per room type") +
  theme_minimal() +
  theme(strip.text.x = element_text(size = 10), legend.position = "none")




```
> We saw that although the total room price for apartments is higher than the one for shared rooms & hotel rooms in total, the price difference is smaller if you account for the number of accomodates which can be fit in one apartment. Now the median price per person is nearly identical among these 3 categories. Private rooms are still an outlier, but we think it is due to the same reasoning as above. 



## Model

We will try to find the best fitting model to predict per night prices

```{r}
athens_data_final %>% 
  na.omit() %>% 
  select_if(is.numeric) %>% 
  cor() %>% 
  as.data.frame() %>% 
  select(price) %>% 
  add_rownames(var = "variable") %>%
  arrange(price) %>% 
  ggplot(aes(x = price, y = reorder(variable, price))) +
  geom_col() +
  ylab("") +
  xlab("Correlation") +
  labs(title = "Distance from central is the most negative correlation",
       subtitle = "Correlations with price")

athens_data_final %>% 
  ggplot(aes(x=cent_dist, y=price)) +
  geom_point()
```

Using correlations doesnt seem to work too well, we will need to find another way

### Possible models

```{r}
# First we will split our data into a training and testing set
# Set seed so we will get the same results
set.seed(202119)

size <- floor(0.75 * nrow(athens_data_final))
train_ind <- sample(seq_len(nrow(athens_data_final)), size = size)

train <- athens_data_final[train_ind, ]
test <- athens_data_final[-train_ind, ]
```

OLS
```{r}
library(stats)

# To choose a model we will use Akaike's information criterion

# Univariate regression

model1 <- lm(log(price) ~ as.factor(accommodates), data=train) 
# Are airbnbs that accomodate 8 people necessarily 2 times as expensive? We do not think so, therefore we use factors instead.

summary(model1) 
summary(model1)$r.squared # R2 same as correlation squared, because of univariate model
# cor(log(train$price), train$accommodates)^2

model1 %>% AIC() # 13195


# Multivariate Regression

# Judging by the correlations we can predict which variables might have a bigger impact, now we will use how many people the airbnb accomodates and how many bedrooms there are

model2 <- lm(log(price) ~ accommodates + bedrooms, data=train)

summary(model2) 
summary(model2)$r.squared

model2 %>% AIC() # 13479

# Both the r2 and the AIC is smaller with this model, which means that the previous one would be prefered

model2 <- lm(log(price) ~ accommodates + cent_dist, data=train)

summary(model2) 
summary(model2)$r.squared

model2 %>% AIC() # 12580

# Our r2 is much better now, and our Akaike criterion also droped by quite a big margin. This is likely due to the fact, that the distance from the center is a big factor when people price airbnbs

model3 <- lm(log(price) ~ accommodates + cent_dist + room_type, data=train)

summary(model3) 
summary(model3)$r.squared

model3 %>% AIC() # 11907

# With the room types we could improve our model also.

train %>% 
  ggplot(aes(x = review_scores_rating, y = price)) +
  geom_point()

model3 <- lm(log(price) ~ accommodates + cent_dist + room_type + bedrooms + bathrooms + review_scores_rating + host_is_superhost, data=train)

summary(model3) 
summary(model3)$r.squared

model3 %>% AIC() # 11907
```

